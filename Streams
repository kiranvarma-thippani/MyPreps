public class Summations {
	public static void main(String[] args)
	{
		//=============================================
		List<Integer> numbers=Arrays.asList(1,4,3,4,10,11,18);
		int l=numbers.stream().mapToInt(Integer::intValue).sum();
		System.out.println("sum= "+l);
		
		/*Here the Integer stream of objects are converted into primitive intStream using mapToInt(Integer::intValue)and mainly
		 for calculating the min, sum, average, max which areS not available on Stream<Integer> Object*/
		
		//Integer::intVlaue mainly converts the Integer Object value to the int value
		//Integer::valueOf() will convert the incoming stream to Stream<Integer>
		/*Integer::valueOf is a static method that converts:
            1. a primitive int to an Integer object
            2. or a String to an Integer object */
		//mapToObj in case primitive int to Integer object.
		//map(Integer::valueOf) or map(Integer::parseInt)
		//==============================================
	  
		List<Integer> sorted=numbers.stream().sorted(Comparator.comparing(Integer::intValue).reversed())
		.collect(Collectors.toList());
		System.out.println("Sorted Collection "+sorted);
		
		/*Here we sort using the sorted() method, if the incoming object implements the comparable then its
		 * sorted without any comparator requirement. But for the custom objects we should specify it. 
		 * for primitive data types, we use sorted().reversed and for Object types we should pass the COmparator
		 * object inside the sorted method and for reversal use Collections.reverse(comparator) and do it
		 * 
		 * SImilary for max() and min() for primitive data types, we should use the direct methods but for
		 * all the object types we should definitly pass the comparator and we do also have that comparator.comparing,
		 * comparingLong and comparingFloat methods also in java 9. Use those use nulls also.
		 * for all the summations, averages, min and max calculations it gives the optional out put. 
		 * use skip for skipping the numbers and limit is to place the limit and findfirst is to return the first
		 * elemen in the list. So thats all for this pdf
		
		 * */
		
		//=============================================================
		double i=numbers.stream().mapToInt(Integer::intValue).average().getAsDouble();
	    double numberList=numbers.stream()
				.filter(s->s%2==0).mapToInt(j->j*j).average().getAsDouble();
		System.out.println(numberList);
		
		 //maximum
		 int z=numbers.stream().max(Comparator.comparingInt(Integer::valueOf)).get();
		System.out.println(z);
	}
}

Stream Methods in java:

Stream.of(elements); --> Direct Stream creation using elements.
Arrays.Stream(array); --> Stream using Array.
List.stream(), set.stream()--> Streams from set and list.
Stream.empty() --> empty stream.
Stream.builder().add(object obj).add(Object obj).add(Object obj).build will create a stream.


Stream Pipeline-> we can build the stream pipeline with stream + intermediate Operation+ Terminal Operation.

+> Whenever we apply the intermediate operation on the stream object it will give again a stream object with applied function on it.
=> Hence we can call many intermediate methods on the same stream object as chain of methods.
=> This is called methods pipelined on the source stream.
=> Intermediate operations only start executing only when the terminal operation is started.
=> We can call only one terminal method on one stream instance. When we call the terminal method, we will get the result of 
the pipelined intermediate methods.
=> Dont use the sane stream everytime that means we cannot use one stream again and againx

Initialisation methods:

.of()
Arrays.stream().
list.stream();

Intermediate methods:

1. map(Function)
2. filter(predicate)
3. sorted()
4. distinct()
5. maptoDouble()
6. mapToInt()---> Integer::intValue conversion object to intstream., Integer::valueOf() ---> Use in comparator instances
7. mapToFloat()-> same
8. limit(n) from begining to n numbers.
9. skip(n) skip the first n numbers.
10. flatmap(List::Stream)
11. peek() u

Terminals:
==========
1. allmatch(predicate)
2. anymatch(predicate)
3. findfirst()
4. findany()
5. collect()



map and flatmap:

map is used to transform each element in a stream. It takes a function and applies it to every element, 
returning a new stream with the transformed elements.

latMap is used when each element might itself be a stream or collection, and you want to flatten those 
into a single stream.

Use map:
=========
You want to transform each element of the stream into another form.
The transformation returns a single value per element.
Youâ€™re not dealing with nested structures.

Use flatmap when deal with nested structures. it creates a stream for each element and then flattens. Stream<string


Sorted()
sorted()-> when the object class implements the comparable interface, then we will use method
sorted(Comparator)-> Should pass a comparator for custom sorting. 
1. pass a lambda expression if you want to have the customised and having full control on the customisation.
2. Comparator.comparing(key)-> based on the key it will sort, it will return a comparator object.
3. thencomparing()-> chaining. this can be applied only on the Comparator refernece variable.

sorted(Comparator.comparinng(Employye::getSalary) will sorts the stream of objects in ascending order and gives you a new
stream.
sorted(Collections.reverseOrder(Comparator.comparing(Employee::getSalary))) reverses the sorting order.


Max()
=====
If its integer or float or long or double stream then directly use max().

If its User defined classes like employees then you should mention the comparator and in which on what param to calculate the min and max()

EmployeeList.stream().max(Comparator.comparingDouble(Employee::getSalary).

It returns a optional class.

Similary for the min() as well.

==========

Collectors.groupingBy and Collectors.mapping(),Collectors.counting.

Terminal Operation Methods:
===========================
1. collect(Collectors)==> Collects the stream data after the intermediate opertions.

Collectors is having a lot utility functions in stream api here they are:

Colectors.toList()


Collects elements into a Map. Overloads:
- toMap(keyMapper, valueMapper)
- toMap(keyMapper, valueMapper, mergeFunction)
- toMap(keyMapper, valueMapper, mergeFunction, mapSupplier)


- joining()
- joining(delimiter)
- joining(delimiter, prefix, suffix)

groupingBy(classifier)
- groupingBy(classifier, downstream)
- groupingBy(classifier, mapFactory, downstream)

Partitions elements by a predicate. Overloads:
- partitioningBy(predicate)
- partitioningBy(predicate, downstream)


statiscts
IntSummaryStatistics stats = stream.collect(Collectors.summarizingInt(String::length));


- reducing(identity, accumulator)
- reducing(identity, mapper, accumulator)

int total = stream.collect(Collectors.reducing(0, String::length, Integer::sum));


mapping()
Applies a mapping function before collecting.
Example:
List<Integer> lengths = stream.collect(Collectors.mapping(String::length, Collectors.toList()));


collectingAndThen()
Applies a finishing transformation after collecting.
Example:
List<String> unmodifiable = stream.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList));

First Non Repeating character in the string:
 1.use the condition s.IndexOf()==s.lastIndex()

Find the first repeating characters in the string;
String s = "yourStringHere";
Map<Character, Long> charMap = s.chars()
    .mapToObj(c -> (char) c)
    .collect(Collectors.groupingBy(
        Function.identity(),
        LinkedHashMap::new,
        Collectors.counting()
    ));

char ans = charMap.entrySet().stream()
    .filter(m -> m.getValue() > 1)
    .map(Map.Entry::getKey)
    .findFirst()
    .get();

System.out.println(ans);

STreamAPI.java

	Integer[] arr= {2,3,10,14,20,24,30,34,40,44,50,54};
	List<Integer> list=Arrays.asList(arr);
	Map<Integer,List<Integer>> segregate=list.stream().collect(Collectors.groupingBy(x->x/10*10));
	System.out.println(segregate);
	
String Regex:
1. \\d+ any digit matching 1 or more, *=> 0 or more, ?=>0 or 1.
2. \\w+ any character a-z,A-Z,0-9, +
3. ^ starts with
4. $ ends with
5. [a-zA-z] consists of a-z, + 1 or more matches
6. [0-9]+ one digit or more digit matches.
7. . -> matches dot.
8. @ matches @symbol
9. \w{2,} atleast 2 characters matches
10. [^a-d ]


Sunm of even numbers.
====================
package StreamApiQuestions;

import java.util.List;

public class EvenNumbers {
	
	public static void main(String[] args) {
		
		List<Integer> list=List.of(1,2,3,4,5,6,7,8,10,11,12,15,30,25,23,32);
		
		long j=list.stream().filter(i->i%2==0).reduce(0,(a,b)->a+b);
		System.out.println(j);
		
		
	}

}

Prime Numbers Logic:
==================
package StreamApiQuestions;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class PrimeNumbers {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 3, 4, 5, 10, 11, 15, 17, 20);

        List<Integer> primes = numbers.stream()
            .filter(PrimeNumbers::isPrime)
            .collect(Collectors.toList());

        System.out.println("Prime Numbers: " + primes);
    }

    private static boolean isPrime(int num) {
        if (num <= 1) return false;
       return IntStream.rangeClosed(2, (int)Math.sqrt(num)).allMatch(n->num%2!=0);
    }
}

Check if every number in a list is positive.

public class EvenNumbers {
	
	public static void main(String[] args) {
		
		List<Integer> list=List.of(1,2,3,4,5,6,7,8,10,11,12,15,30,25,23,32);
		
	   boolean b=list.stream().allMatch(i->i>0);
	   System.out.println(b);
		
		
	}

}

Identify the number that occurs the most frequently in a collection.

	List<Integer> list=List.of(1,2,3,4,5,6,7,8,10,11,12,15,30,25,23,32,2,2,2,4,6,4,9,10,15,30);
		
	 int i=  list.stream().
			   collect(Collectors.groupingBy(Function.identity(),Collectors.counting()))
			   .entrySet().stream().max(Map.Entry.comparingByValue()).get().getKey();
		
		


